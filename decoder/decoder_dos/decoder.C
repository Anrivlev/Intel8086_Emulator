/* Перекодировщик текста.Таблицы кодировок перекодировщик берёт из файла конфигурации (recof.cfg),
   по умолчанию находящегося в той же директории, где и экзешник (recof.exe).

   ВНИМАНИЕ!!! Имя файла конфигурации всегда совпадает с именем экзешника!
   Будьте внимательны при переименовании.

Параметры вызова программы:   recof  infile outfile chain [cfgfile]
   infile  - входной файл.
   outfile - выходной файл.
   chain   - последовательность перекодировок. Формат: [@]ioioio...
	     i - первая буква названия входной кодовой таблицы.
	     o - первая буква названия выходной кодовой таблицы.
	     @ - этот символ добавляется в случае ФИДО-замены, когда
		 в результате применения последовательности перекодировок
		 текст получается в целом правильный, но только вместо одной
		 из букв во всём тексте получается латинская H. Это говорит
		 о том, что последним присутствовал гейт Интернет-ФИДО,
		 который заменил в своём выходном файле все русские буквы Н
		 на латинские H. Добавление символа @ позволяет перед
		 применением последовательности перекодировок осуществить
		 обратную замену.
	     Примеры:  awka   @akwa   @akwkwa
   cfgfile - имя файла конфигурации, если по каким-то причинам стандартный
      не устраивает (или хотим попробовать другой набор кодовых таблиц).

В файле конфигурации:

; - комментарий. Комментариев может быть сколько угодно, между любыми
     строками.
*win - название кодировки.
41 A  - 16-ричный код символа и его изображение. Изображение может быть
C2 42 - символом или его 16-ричным кодом в альтернативной кодировке.
!!!Нет! Может быть _только_ 16-ричным кодом!
C0-CF юабцдефгхийклмно - изображения символов от и до. В виде байтов!
     То есть фактически после названия кодировки находится таблица
     перекодировки из этой кодировки в альтернативную.
     Если какой-либо код не представлен в таблице кодировки, значит,
     изображение равно коду символа. Таким образом, необязательно описывать
     всю таблицу. Таблицу alt описывать вообще не нужно. ;)

В конце файла конфигурации _обязательно_ должен быть 0D0A.
*/

#include <stdio.h>
#include <process.h>
#include <string.h>
#include <dos.h>
#include <conio.h>

#define EE(N,S,N1,N2) { printf("\n*** ОШИБКА ***  К терапевту! Ошибка алгоритма %d: " S,N,N1,N2); exit(-1); }
#define ER(A) { printf("\n*** ОШИБКА ***  "); printf(A " !\n"); fprintf(stderr," ... исправь ошибку!\n"); exit(-1); }
#define ES(A,S) { printf("\n*** ОШИБКА ***  "); printf(A " !\n",S); fprintf(stderr," ... исправь ошибку!\n"); exit(-1); }
#define EO(A) { printf("\n*** ОШИБКА ***  неожиданный конец файла! (%d)\n",A); fprintf(stderr," ... исправь ошибку!\n"); exit(-1); }

#define	MAXT	8	/* максимальное количество таблиц. */
#define MKRAT	16	/* максимальная кратность перекодировки. */

unsigned char	tab[MAXT][256], tao[MAXT][256]; /* прямые таблицы (таб->alt) и обратные (alt->таб). */
unsigned char	nam[MAXT][32];
unsigned char	namcfg[133];
unsigned char	t[256];

FILE	*cf,*cs,*co; /* конфигурация, входной, выходной. */

unsigned char	c;
unsigned char	s[64],r[64];
int		i,i1,i2,ir, in,ik,ik_, ls,nt, e;
int		ind; /* индикатор режима перебора: 0 - наиболее вероятные комбинации, 1 - остальные. */
int		krat, pn[MKRAT],pk[MKRAT]; /* кратность перекодировки и таблица последовательностей перекодировки. */
int		fifi;	/* флаг "контр-ФИДО". */

void help(void);
int  keyno(unsigned char *);

void main(int Argc, unsigned char **Argv)
{

/* Разберёмся с параметрами. */
if (Argc<4 || Argc>5) help();
for (i=1; i<Argc; i++) if (strchr(Argv[i],'?')) help();

if (Argc==5) strcpy(namcfg,Argv[4]);
else
{
   strcpy(namcfg,Argv[0]);
   i=strlen(namcfg); if (i<8 || i>127) EE(1,"%d %s",i,Argv[0])
   strcpy(namcfg+i-3,"CFG");
}
if ((co=fopen(Argv[2],"rb"))!=NULL)
{
   if (keyno(Argv[2])) exit(1);
   if (fclose(co)) EE(11,"%d %s",Argc,Argv[2]);
}
if ((co=fopen(Argv[2],"wb"))==NULL) ES("не удаётся открыть файл %s на запись",Argv[2])
if ((cs=fopen(Argv[1],"rb"))==NULL) ES("не открывается входной файл %s",Argv[1])

/* "Подразумеваемая" таблица alt. */
strcpy (nam[0],"alt");
for (i=0; i<256; i++) tab[0][i]=i;
nt=1;

/* Прочтём из cfg таблицы. */

if ((cf=fopen(namcfg,"rb"))==NULL) ES("не могу открыть файл конфигурации %s",namcfg)
printf("\nЧитаю файл конфигурации %s...\n\n",namcfg);
if (fread(&c,1,1,cf)!=1) ES ("пустой файл конфигурации %s",namcfg)
while (c==';')
{
   while(c!=0x0A) if (fread(&c,1,1,cf)!=1) EO(31)
   if (fread(&c,1,1,cf)!=1) ER("в файле конфигурации после комментариев ничего нет")
}
/*putchar(c);*/
if (c!='*') ER ("имя таблицы должно начинаться с '*'")
while ((ir=fread(&c,1,1,cf))==1)
{
   if (nt>=MAXT) ER("многовато таблиц")
   /* 1. Имя таблицы. */
   i=0;
   while (c!=0x0A)
   {
      if (c==0x0D) nam[nt][i]=0; else nam[nt][i]=c, putchar(c);
      i++; if (i>31) ER ("слишком длинное имя таблицы")
      if (fread(&c,1,1,cf)!=1) ER ("неожиданный конец файла конфигурации")
   }
   /*printf("\nТаблица %s.\n",&nam[nt]);*/ printf("\n");
   /* 2. Тело таблицы. */
   for (i=0; i<256; i++) t[i]=i;
   while(1)
   {
mk1:  if (fread(&c,1,1,cf)!=1) break; if (c=='*') break;
      if (c==';') {while(c!=0x0A) if (fread(&c,1,1,cf)!=1) EO(32) goto mk1;}
      putchar(c);
      if (c<'0' || c>'F' || (c>'9'&&c<'A')) ES("В диапазоне - не цифра: %c",c)
      if (c>'9') i1=c-'A'+10; else i1=c-'0';
      if (fread(&c,1,1,cf)!=1) EO(1) putchar(c);
      if (c<'0' || c>'F' || (c>'9'&&c<'A')) ES("В диапазоне - не цифра: %c",c)
      if (c>'9') i2=c-'A'+10; else i2=c-'0';
      in=i1*16+i2;
      if (fread(&c,1,1,cf)!=1) EO(2) putchar(c);
      if (c==' ')
      {
	 /* 2.1. Код - пробел - заменяющий код. */
	 /* !!! Этот фрагмент не тестировался! */
	 if (fread(&c,1,1,cf)!=1) EO(3) putchar(c);
	 if (c<'0' || c>'F' || (c>'9'&&c<'A')) ES("В коде - не цифра: %c",c)
	 if (c>'9') i1=c-'A'+10; else i1=c-'0';
	 if (fread(&c,1,1,cf)!=1) EO(4) putchar(c);
	 if (c<'0' || c>'F' || (c>'9'&&c<'A')) ES("В коде - не цифра: %c",c)
	 if (c>'9') i2=c-'A'+10; else i2=c-'0';
	 t[in]=i1*16+i2;
	 printf(" : (%02X)=%02X\n", in, t[in]);
	 if (fread(&c,1,1,cf)!=1) break;
	 if (c!=0x0D) ER("после кода нет 0D")
	 if (fread(&c,1,1,cf)!=1) EO(5)
	 if (c!=0x0A) ER("после кода нет 0D0A")
      }
      else
      {
	 /* 2.2. Диапазон - строка символов. */
	 if (c!='-') ER("После кода начала нужен пробел или минус");
	 if (fread(&c,1,1,cf)!=1) EO(6) putchar(c);
	 if (c<'0' || c>'F' || (c>'9'&&c<'A')) ES("В диапазоне - не цифра: %c",c)
	 if (c>'9') i1=c-'A'+10; else i1=c-'0';
	 if (fread(&c,1,1,cf)!=1) EO(7) putchar(c);
	 if (c<'0' || c>'F' || (c>'9'&&c<'A')) ES("В диапазоне - не цифра: %c",c)
	 if (c>'9') i2=c-'A'+10; else i2=c-'0';
	 ik=i1*16+i2;
	 if (fread(&c,1,1,cf)!=1) EO(8) putchar(c);
	 if (c!=' ') ER("после диапазона должен быть один пробел")
	 for (i=in; i<=ik; i++)
	 {
	    if (fread(&c,1,1,cf)!=1) EO(9) putchar(c);
	    t[i]=c;
	 }
	 printf(" : %02X-%02X:",in,ik);
	 for (i=in; i<=ik; i++) printf(" %02X", t[i]);
	 printf("\n");
	 if (fread(&c,1,1,cf)!=1) break;
	 if (c!=0x0D) ER("после строки нет 0D")
	 if (fread(&c,1,1,cf)!=1) EO(10)
	 if (c!=0x0A) ER("после строки нет 0D0A")
      }
   }
   /*printf("\nТаблица вся.");*/
   for (i=0; i<256; i++) tab[nt][i]=t[i];
   nt++;
   /*printf("\n");*/ if (c=='*') putchar('*');
}

/* Проанализируем таблицы. */

printf("\nВсего таблиц: %d\n",nt);
printf("\nАнализ таблиц.\n~~~~~~~~~~~~~~");
e=0;
for (in=0; in<nt; in++)
{
   printf("\n%d. %c - таблица %s:",in+1,nam[in][0],nam[in]); ik=0;
   for (i1=0; i1<256; i1++)
   {
      i2=0; for (i=0; i<256; i++) if (tab[in][i]==i1) i2++;
      if (i2!=1) printf("\nКодов %02X всего %d, а должно быть 1 !",i1,i2), e++, ik++;
   }
   if (ik) printf("\n--- Ошибок в таблице: %d",ik);
   else
   {
      printf(" годится.");
      /* Построим обратную таблицу. */
      for (i=0; i<256; i++) tao[in][i]=0; /* на вс.сл. */
      for (i=0; i<256; i++) tao[in][tab[in][i]]=i; /* вот она, обратная. */
      /* И анализ обратной - на всякий случай. */
      for (i1=0; i1<256; i1++)
      {
	 i2=0; for (i=0; i<256; i++) if (tao[in][i]==i1) i2++;
	 if (i2!=1)
	 {
	    printf("??? Кодов %02X всего %d, а должно быть 1 !",i1,i2);
	    EE(2,"%02X %d",i1,i2)
	 }
      }
   }
}

for (i1=0; i1<nt; i1++) for (i2=i1+1; i2<nt; i2++)
   if (nam[i1][0]==nam[i2][0]) printf("\n Таблицы %s и %s : первые символы в названиях должны быть разными!",nam[i1],nam[i2]), e++;

if (e)
{
   /*fprintf(stderr,"... ошибок: %d \n",e);*/
   printf("\n\n************* Всего ошибок: %d *******************\n",e);
   exit(-1);
}

/* Разберём цепочку перекодировки в Argv[3]. */

printf("\n\nЦепочка перекодировки: ");
if (Argv[3][0]=='@') putchar('@'), putchar(' '), fifi=1, ik_=1;
else fifi=0, ik_=0;
krat=0;

while(Argv[3][ik_])
{
   c=Argv[3][ik_];
   putchar(c);
   for (in=0; in<nt; in++) if (nam[in][0]==c) break;
   if (in>=nt) ES ("нет таблицы, начинающейся с буквы %c",c)
   ik_++; c=Argv[3][ik_]; if (!c) ES("непарная перекодировка! Откуда - понятно (%c), куда - нет",nam[in][0])
   putchar(c);
   for (ik=0; ik<nt; ik++) if (nam[ik][0]==c) break;
   if (ik>=nt) ES ("нет таблицы, начинающейся с буквы %c",c)
   if (krat>=MKRAT) ER("слишком длинная цепочка перекодировки")
   pn[krat]=in; pk[krat]=ik; krat++; putchar(' ');
   ik_++;
}

/* Перекодируем... */

printf("  -  кратность %d.\nВыполняю перекодировку...",krat);
while (fread(&c,1,1,cs)==1)
{
   if (fifi && c=='H') c='Н';
   for (i=0; i<krat; i++) c=tao[pk[i]][tab[pn[i]][c]];
   if (fwrite(&c,1,1,co)!=1) ER("ПЕРЕПОЛНЕНИЕ выходного файла")
}

printf(" готово.\n"); exit(0);

}

int keyno(unsigned char *ff)
{
unsigned char q=' ';
   fprintf(stderr,"\nФайл %s уже существует. Затирать? (Y/N) ",ff);
   while (q!='n' && q!='y' && q!='N' && q!='Y')
      { sound(440); delay(300); nosound(); q=getche(); }
   if (q=='y' || q=='Y') return 0; else return 1;
}

void help(void)
{
   fprintf(stderr,
"\nМногократный перекодировщик текста.\n"
"\n       recof  infile outfile chain [cfgfile]\n"
"\n  infile  - входной файл"
"\n  outfile - выходной файл (по умолчанию вывод на экран)"
"\n  chain   - цепочка перекодировки (строка символов без пробелов)"
"\n            Примеры:   awka   @akwa  akwkwa    (@ - в начале контр-ФИДО H->Н)"
"\n  cfgfile - файл конфигурации (по умолчанию имя совпадает с именем exe-шника,"
"\n            а расположение - в директории exe-шника)\n"
"\nВ файле конфигурации могут находиться более подробные комментарии. ;)\n"
);
exit(1);
}