/* Перекодировщик текста.
   Таблицы кодировок перекодировщик берёт из файла конфигурации (recof.cfg),
   по умолчанию находящегося в той же директории, где и экзешник (recof.exe).

   ВНИМАНИЕ!!! Имя файла конфигурации всегда совпадает с именем экзешника!
   Будьте внимательны при переименовании.

Параметры вызова программы:   recof  infile outfile chain [cfgfile]
   infile  - входной файл.
   outfile - выходной файл.
   chain   - последовательность перекодировок. Формат: [@]ioioio...
	     i - первая буква названия входной кодовой таблицы.
	     o - первая буква названия выходной кодовой таблицы.
	     @ - этот символ добавляется в случае ФИДО-замены, когда
		 в результате применения последовательности перекодировок
		 текст получается в целом правильный, но только вместо одной
		 из букв во всём тексте получается латинская H. Это говорит
		 о том, что последним присутствовал гейт Интернет-ФИДО,
		 который заменил в своём выходном файле все русские буквы Н
		 на латинские H. Добавление символа @ позволяет перед
		 применением последовательности перекодировок осуществить
		 обратную замену.
	     Примеры:  awka   @akwa   @akwkwa
   cfgfile - имя файла конфигурации, если по каким-то причинам стандартный
      не устраивает (или хотим попробовать другой набор кодовых таблиц).

В файле конфигурации:

; - комментарий. Комментариев может быть сколько угодно, между любыми
     строками.
*win - название кодировки.
41 A  - 16-ричный код символа и его изображение. Изображение может быть
C2 42 - символом или его 16-ричным кодом в альтернативной кодировке.
!!!Нет! Может быть _только_ 16-ричным кодом!
C0-CF юабцдефгхийклмно - изображения символов от и до. В виде байтов!
     То есть фактически после названия кодировки находится таблица
     перекодировки из этой кодировки в альтернативную.
     Если какой-либо код не представлен в таблице кодировки, значит,
     изображение равно коду символа. Таким образом, необязательно описывать
     всю таблицу. Таблицу alt описывать вообще не нужно. ;)

В конце файла конфигурации _обязательно_ должен быть 0D0A.
*/

#include <stdio.h>
#include <process.h>
#include <string.h>
#include <dos.h>
#include <conio.h>

#define EE(N,S,N1,N2) { printf("\n*** ОШИБКА ***  К терапевту! Ошибка алгоритма %d: " S,N,N1,N2); exit(-1); }
#define ER(A) { printf("\n*** ОШИБКА ***  "); printf(A " !\n"); fprintf(stderr," ... исправь ошибку!\n"); exit(-1); }
#define ES(A,S) { printf("\n*** ОШИБКА ***  "); printf(A " !\n",S); fprintf(stderr," ... исправь ошибку!\n"); exit(-1); }
#define EO(A) { printf("\n*** ОШИБКА ***  неожиданный конец файла! (%d)\n",A); fprintf(stderr," ... исправь ошибку!\n"); exit(-1); }

#define	MAXT	8	/* максимальное количество таблиц. */
#define MKRAT	16	/* максимальная кратность перекодировки. */

unsigned char	tab[MAXT][256], tao[MAXT][256]; /* прямые таблицы (таб->alt) и обратные (alt->таб). */
unsigned char	nam[MAXT][32];
unsigned char	namcfg[133];
unsigned char	t[256];

FILE	*cf,*cs,*co; /* конфигурация, входной, выходной. */

unsigned char	c;
unsigned char	s[64],r[64];
int		i, i1, i2, ir, in, ik, ik_, ls, nt, e;
int		ind; /* индикатор режима перебора: 0 - наиболее вероятные комбинации, 1 - остальные. */
int		krat, pn[MKRAT], pk[MKRAT]; /* кратность перекодировки и таблица последовательностей перекодировки. */
int		fifi;	/* флаг "контр-ФИДО". */

void help(void);
int  keyno(unsigned char *);

void main(int Argc, unsigned char **Argv)
{

/* Разберёмся с параметрами. */

    if (Argc < 4 || Argc > 5)
        help();
    for (i = 1; i < Argc; i++)
        if (strchr(Argv[i], '?'))
            help();

    if (Argc == 5)
        strcpy(namcfg, Argv[4]);
    else
    {
        strcpy(namcfg, Argv[0]);
        i = strlen(namcfg);
        if (i < 8 || i > 127)
            EE(1,"%d %s", i,Argv[0])
        strcpy(namcfg+i-3, "CFG");
    }
    if ((co = fopen(Argv[2], "rb")) != NULL)
    {
        if (keyno(Argv[2]))
            exit(1);
        if (fclose(co))
            EE(11,"%d %s", Argc,Argv[2]);
    }
    if ((co = fopen(Argv[2], "wb")) == NULL)
        ES("не удаётся открыть файл %s на запись",Argv[2])
    if ((cs = fopen(Argv[1], "rb")) == NULL)
        ES("не открывается входной файл %s",Argv[1])

/* "Подразумеваемая" таблица alt. */
    strcpy(nam[0], "alt");
    for (i = 0; i < 256; i++)
        tab[0][i] = i;
    nt = 1;

/* Прочтём из cfg таблицы. */

    if ((cf = fopen(namcfg, "rb")) == NULL)
        ES("не могу открыть файл конфигурации %s", namcfg)
    printf("\nЧитаю файл конфигурации %s...\n\n", namcfg);
    if (fread(&c,1,1, cf) != 1)
        ES("пустой файл конфигурации %s", namcfg)
    while (c == ';')
    {
        while(c != 0x0A)
            if(fread(&c,1,1, cf) != 1)
                EO(31)
        if (fread(&c,1,1, cf) != 1)
            ER("в файле конфигурации после комментариев ничего нет")
    }
/*putchar(c);*/
    if (c != '*')
        ER("имя таблицы должно начинаться с '*'")
    while ((ir = fread(&c,1,1, cf)) == 1)
    {
        if (nt >= MAXT)
            ER("многовато таблиц")
        /* 1. Имя таблицы. */
        i = 0;
        while(c != 0x0A)
        {
            if(c == 0x0D)
                nam[nt][i] = 0;
            else {
                nam[nt][i] = c;
                putchar(c);
            }
            i++;
            if(i > 31)
                ER("слишком длинное имя таблицы")
            if(fread(&c,1,1, cf) != 1)
                ER("неожиданный конец файла конфигурации")
        }
        /*printf("\nТаблица %s.\n",&nam[nt]);*/ printf("\n");
        /* 2. Тело таблицы. */
        for (i = 0; i < 256; i++)
            t[i] = i;
        while(1)
        {
            mk1:
            if(fread(&c,1,1, cf) != 1)
                break;
            if (c=='*')
                break;
            if (c==';')
            {
                while(c!=0x0A)
                    if (fread(&c,1,1,cf)!=1)
                        EO(32)
                 goto mk1;
            }
            putchar(c);
            if (c < '0' || c > 'F' || (c > '9' && c < 'A'))
                ES("В диапазоне - не цифра: %c", c)
            if (c > '9')
                i1 = c - 'A' + 10;
            else i1 = c - '0';
            if (fread(&c,1,1, cf) != 1)
                EO(1) putchar(c);
            if (c < '0' || c > 'F' || (c > '9' && c < 'A'))
                ES("В диапазоне - не цифра: %c", c)
            if (c > '9')
                i2 = c - 'A' + 10;
            else i2 = c - '0';
            in = i1*16 + i2;
            if (fread(&c,1,1, cf) != 1)
                EO(2) putchar(c);
            if (c == ' ')
            {
                /* 2.1. Код - пробел - заменяющий код. */
                /* !!! Этот фрагмент не тестировался! */
                if (fread(&c,1,1, cf) != 1)
                    EO(3) putchar(c);
                if (c < '0' || c > 'F' || (c > '9' && c < 'A'))
                    ES("В коде - не цифра: %c", c)
                if (c > '9')
                    i1 = c - 'A' + 10;
                else i1 = c - '0';
                if (fread(&c,1,1, cf) != 1)
                    EO(4) putchar(c);
                if (c < '0' || c > 'F' || (c > '9' && c < 'A'))
                    ES("В коде - не цифра: %c", c)
                if (c > '9')
                    i2 = c - 'A' + 10;
                else i2 = c - '0';
                t[in] = i1*16 + i2;
                printf(" : (%02X)=%02X\n", in, t[in]);
                if (fread(&c,1,1, cf) != 1)
                    break;
                if (c != 0x0D)
                    ER("после кода нет 0D")
                if (fread(&c,1,1, cf) != 1)
                    EO(5)
                if (c != 0x0A)
                    ER("после кода нет 0D0A")
            }
            else
            {
                /* 2.2. Диапазон - строка символов. */
                if (c != '-')
                    ER("После кода начала нужен пробел или минус");
                if (fread(&c,1,1, cf) != 1)
                    EO(6) putchar(c);
                if (c < '0' || c > 'F' || (c > '9' && c < 'A'))
                    ES("В диапазоне - не цифра: %c", c)
                if (c > '9')
                    i1 = c - 'A' + 10;
                else i1 = c - '0';
                if (fread(&c,1,1, cf) != 1)
                    EO(7) putchar(c);
                if (c < '0' || c > 'F' || (c > '9' && c < 'A'))
                    ES("В диапазоне - не цифра: %c", c)
                if (c > '9')
                    i2 = c - 'A' + 10;
                else i2 = c - '0';
                ik = i1*16 + i2;
                if (fread(&c,1,1, cf) != 1)
                    EO(8) putchar(c);
                if (c != ' ')
                    ER("после диапазона должен быть один пробел")
                for (i = in; i <= ik; i++)
                {
                    if (fread(&c,1,1, cf) != 1)
                        EO(9) putchar(c);
                    t[i] = c;
                }
                printf(" : %02X-%02X:", in, ik);
                for (i = in; i <= ik; i++)
                    printf(" %02X", t[i]);
                printf("\n");
                if (fread(&c,1,1, cf) != 1)
                    break;
                if (c != 0x0D)
                    ER("после строки нет 0D")
                if (fread(&c,1,1, cf) != 1)
                    EO(10)
                if (c != 0x0A)
                    ER("после строки нет 0D0A")
            }
        }
        /*printf("\nТаблица вся.");*/
        for (i = 0; i < 256; i++)
            tab[nt][i] = t[i];
        nt++;
        /*printf("\n");*/
        if (c == '*')
            putchar('*');
    }

/* Проанализируем таблицы. */

    printf("\nВсего таблиц: %d\n", nt);
    printf("\nАнализ таблиц.\n~~~~~~~~~~~~~~");
    e = 0;
    for (in = 0; in < nt; in++)
    {
        printf("\n%d. %c - таблица %s:", in+1, nam[in][0], nam[in]);
        ik = 0;
        for (i1 = 0; i1 < 256; i1++)
        {
            i2 = 0;
            for (i = 0; i < 256; i++)
                if (tab[in][i] == i1)
                    i2++;
            if (i2 != 1)
            {
                printf("\nКодов %02X всего %d, а должно быть 1 !", i1, i2);
                e++;
                ik++;
            }
        }
        if (ik)
            printf("\n--- Ошибок в таблице: %d", ik);
        else
        {
            printf(" годится.");
            /* Построим обратную таблицу. */
            for (i = 0; i < 256; i++)
                tao[in][i] = 0; /* на вс.сл. */
            for (i = 0; i < 256; i++)
                tao[in][tab[in][i]] = i; /* вот она, обратная. */
            /* И анализ обратной - на всякий случай. */
            for (i1 = 0; i1 < 256; i1++)
            {
                i2 = 0;
                for (i = 0; i < 256; i++)
                    if (tao[in][i] == i1)
                        i2++;
                if (i2 != 1)
                {
                    printf("??? Кодов %02X всего %d, а должно быть 1 !", i1, i2);
                    EE(2,"%02X %d", i1, i2)
                }
            }
        }
    }

    for (i1 = 0; i1 < nt; i1++)
        for (i2 = i1+1; i2 < nt; i2++)
            if (nam[i1][0] == nam[i2][0])
                printf("\n Таблицы %s и %s : первые символы в названиях должны быть разными!", nam[i1], nam[i2]),
                e++;

    if (e)
    {
        /*fprintf(stderr,"... ошибок: %d \n",e);*/
        printf("\n\n************* Всего ошибок: %d *******************\n", e);
        exit(-1);
    }

/* Разберём цепочку перекодировки в Argv[3]. */

    printf("\n\nЦепочка перекодировки: ");
    if (Argv[3][0] == '@')
    {
        putchar('@'), putchar(' ');
        fifi = 1, ik_ = 1;
    }
    else
        fifi = 0, ik_ = 0;
    krat = 0;

    while(Argv[3][ik_])
    {
        c = Argv[3][ik_];
        putchar(c);
        for (in = 0; in < nt; in++)
            if (nam[in][0] == c)
                break;
        if (in >= nt)
            ES("нет таблицы, начинающейся с буквы %c", c)
        ik_++;
        c = Argv[3][ik_];
        if(!c)
            ES("непарная перекодировка! Откуда - понятно (%c), куда - нет",nam[in][0])
        putchar(c);
        for (ik = 0; ik < nt; ik++)
            if (nam[ik][0] == c)
                break;
        if (ik >= nt)
            ES("нет таблицы, начинающейся с буквы %c", c)
        if (krat >= MKRAT)
            ER("слишком длинная цепочка перекодировки")
        pn[krat] = in;
        pk[krat] = ik;
        krat++;

        putchar(' ');
        ik_++;
    }

/* Перекодируем... */

    printf("  -  кратность %d.\nВыполняю перекодировку...", krat);
    while (fread(&c,1,1, cs) == 1)
    {
        if (fifi && c == 'H')
            c = 'Н';
        for (i = 0; i < krat; i++)
            c = tao[pk[i]][tab[pn[i]][c]];
        if (fwrite(&c,1,1, co) != 1)
            ER("ПЕРЕПОЛНЕНИЕ выходного файла")
    }
    printf(" готово.\n");
    exit(0);
}

int keyno(unsigned char *ff)
{
    unsigned char q = ' ';
    fprintf(stderr,"\nФайл %s уже существует. Затирать? (Y/N) ", ff);
    while (q != 'n' && q != 'y' && q != 'N' && q != 'Y')
    {
        sound(440);
        delay(300);
        nosound();
        q = getche();
    }
    if (q == 'y' || q == 'Y')
        return 0;
    else
        return 1;
}

void help(void)
{
    fprintf(stderr,
            "\nМногократный перекодировщик текста.\n"
            "\n       recof  infile outfile chain [cfgfile]\n"
            "\n  infile  - входной файл"
            "\n  outfile - выходной файл (по умолчанию вывод на экран)"
            "\n  chain   - цепочка перекодировки (строка символов без пробелов)"
            "\n            Примеры:   awka   @akwa  akwkwa    (@ - в начале контр-ФИДО H->Н)"
            "\n  cfgfile - файл конфигурации (по умолчанию имя совпадает с именем exe-шника,"
            "\n            а расположение - в директории exe-шника)\n"
            "\nВ файле конфигурации могут находиться более подробные комментарии. ;)\n"
    );
    exit(1);
}